A=matrix(c(0.5,0,0,0,0,0.9,0.05,0.5,0.5,0.1,0.85,0.3,0,0,0.1,0.2), 4, 4, byrow=TRUE)
x0=c(0,0,1,0)
x10=x0
for(i in 1:10) {
x10= A %*% x10
}
View(x10)
A=matrix(c(0.5,0,0,0,0,0.9,0.05,0.5,0.5,0.1,0.85,0.3,0,0,0.1,0.2), 4, 4, byrow=TRUE)
x0=c(0,0,1,0)
x20=x0
for(i in 1:20) {
x20= A %*% x20
}
for(i in 1:20) {
x20= A %*% x20
}
View(x20)
A=matrix(c(0.5,0,0,0,0,0.9,0.05,0.5,0.5,0.1,0.85,0.3,0,0,0.1,0.2), 4, 4, byrow=TRUE)
x0=c(1,0,0,0)
x20=x0
for(i in 1:20) {
x20= A %*% x20
}
A=matrix(c(0.5,0,0,0,0,0.9,0.05,0.5,0.5,0.1,0.85,0.3,0,0,0.1,0.2), 4, 4, byrow=TRUE)
x0=c(1,0,0,0)
x10=x0
for(i in 1:10) {
x10= A %*% x10
}
View(x10)
View(x20)
A=matrix(c(0.5,0,0,0,0,0.9,0.05,0.5,0.5,0.1,0.85,0.3,0,0,0.1,0.2), 4, 4, byrow=TRUE)
x0=c(1,0,0,0)
x20=x0
for(i in 1:20) {
x20= A %*% x20
}
for(i in 1:20) {
x20= A %*% x20
}
View(x10)
eigen(A)
A=matrix(c(0.5,0,0.2,0,0,0.05,0.05,0.5,0.5,0.42,0.25,0.3,0,0.53,0.5,0.2), 4, 4, byrow=TRUE)
x0=c(0,0,1,0)
eigen(A)
x10=x0
for(i in 1:10) {
x10= A %*% x10
}
for(i in 1:10) {
x10= A %*% x10
}
A=matrix(c(0.5,0,0.2,0,0,0.05,0.05,0.5,0.5,0.42,0.25,0.3,0,0.53,0.5,0.2), 4, 4, byrow=TRUE)
x0=c(0,0,1,0)
eigen(A)
x20=x0
for(i in 1:20) {
x20= A %*% x20
}
View(x10)
View(x20)
install.packages("deSolve")
source("run_logistic.R")
source(run_logistic.R)
results = run_logistic(r-0.2,k=5000,p0=1000,tmax=40)
source("run_linear_ode.R")
install.packages("deSolve")
source("run_linear_ode.R")
run_linear_ode = function(r=0.1, p0=100, tmax=100, nt=51) {
# simulate a linear ODE (ordinary differential equation)
# that models growth/decay:
# dp/dt = r*p
# arguments:
# r: net growth rate
# p0: initial condition for population
# tmax: maximum time for simulation
# nt: number of time points to calculate solution
# all arguments have default values and so are optional.
# For example, to simulate with default arguments
# run_linear_ode()
# Since solution to ODE is p(t) = p0*e^(r*t),
# solving the ODE numerically this way is unnecessary.
# This is just an example of how to use R to solve an ODE.
# For example, to run and specify parameters and initial conditions
# run_linear_ode(p0=500, r=0.05)
# To run same simulation but for longer time
# run_linear_ode(p0=500, r=0.05, tmax=200)
# The function returns a matrix of the calculated population size
# at the specified times (nt points from t=0 until t=tmax).
# To save the results (and keep them from displaying each time)
# run the program as, for example,
# results = run_linear_ode(r=0.1, K=1000)
# Then, can plot the results with the command
# plot(results)
# You can examine the results at the 10th time point with
# results[10,]
# and access just the value of the time as
# results[10,"time"]
# or the population size as
# results[10,"p"]
# function defining the right hand side of the differential equation
# dp/dt = r*p
linear_f = function(t, p, r) {
dp = r*p
# must output results as a list
list(dp)
}
# times where we want to calculate the solution:
# a total of nt points evenly spaced from t=0 to t=tmax
times = seq(0, tmax, length = nt)
# create initial condition as a vector
# with a named component so that plotting the output
# will label graph with p
initial = c(p=p0)
# run the simulation and return the results as the output
ode(y=initial, times=times, func=linear_f, parms=r)
}
source("run_linear_ode.R")
source("run_logistic.R")
source("run_logistic.R").
source("run_logistic.R")
setwd("~/Desktop")
source("run_logistic.R")
results = run_logistic(r=0.2, K=5000, p0=1000, tmax=40)
plot(results)
plot(results, ylim=c(0,6000))
plot(results, ylim=c(0,60000))
plot(results)
plot(results, ylim=c(0,60000))
plot(results, ylim=c(0,6000))
results = run_logistic(r=0.2, K=5000, p0=100, tmax=40)
plot(results, ylim=c(0,6000))
plot(results, ylim=c(0,4000))
results
results = run_logistic(r=0.4, K=5000, p0=100, tmax=40)
plot(results, ylim=c(0,4000))
results
results = run_logistic(r=0.2, K=10000, p0=200, tmax=40)
plot(results, ylim=c(0,8000))
results
plot(results, ylim=c(0,12000))
library(scde)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
data(es.mef.small)
mode.fail.dist <- as.dist(1-do.call(rbind,mclapply(cell.names,function(nam1) {
unlist(lapply(cell.names,function(nam2) {
corr(cbind(mat[, nam1], mat[, nam2]), w = sqrt(sqrt(matw[, nam1]*matw[, nam2])))
}))
}, mc.cores = 1)), upper = FALSE)
library(scde)
data(es.mef.small)
sg <- factor(gsub("(MEF|ESC).*", "\\1", colnames(es.mef.small)), levels = c("ESC", "MEF"))
names(sg) <- colnames(es.mef.small)
table(sg)
cd <- clean.counts(es.mef.small, min.lib.size=1000, min.reads = 1, min.detected = 1)
o.ifm <- scde.error.models(counts = cd, groups = sg, n.cores = 1, threshold.segmentation = TRUE, save.crossfit.plots = FALSE, save.model.plots = FALSE, verbose = 1)
o.ifm <- scde.error.models(counts = cd, groups = sg,
threshold.segmentation = TRUE,
save.crossfit.plots = FALSE, save.model.plots = FALSE,
verbose = 1)
data(o.ifm)
require(devtools)
install.packages("devtools")
require(devtools)
install_version("flexmix", version = "2.3-13", repos = "http://cran.us.r-project.org")
install("flexmix", version = "2.3-13", repos = "http://cran.us.r-project.org")
library(devtools)
install.packages("devtools")
library(devtools)
install.packages(digest)
install.packages("digest")
install.packages("digest")
install.packages("swirl", dependencies = TRUE)
install.packages("digest")
o.ifm <- scde.error.models(counts = cd, groups = sg,
threshold.segmentation = TRUE,
save.crossfit.plots = FALSE, save.model.plots = FALSE,
verbose = 1)
